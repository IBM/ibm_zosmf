# Copyright (c) IBM Corporation 2025
# Apache License, Version 2.0 (see https://opensource.org/licenses/Apache-2.0)

---
# Tasks file for zmf_swmgmt_holds_for_reason play.

# Do not attempt to execute the play without a HOLD REASON.
- name: A HOLD REASON ID must be provided to the role
  ansible.builtin.fail:
    msg: "Specify a HOLD REASON ID and retry the role."
  when: hold_reason is not defined or hold_reason == ''

# Do not attempt to execute the play without any Software Update HOLDs.
- name: Software Update HOLDs must be provided to the playbook
  ansible.builtin.fail:
    msg: "Run the zmf_swupdate_retrieve role before calling this role in the playbook."
  when: software_update_holds is not defined or software_update_holds | length > 0

# Do not attempt to execute the play without a Software Instance UUID.
- name: A Software Instance must be provided to the role
  ansible.builtin.fail:
    msg: "Run the zmf_swupdate_retrieve role first in the playbook prior to calling this role."
  when: software_instance_uuid is not defined or software_instance_uuid == ''

# Initialize the lists of HOLDS & PTFs.
- name: Initialize the lists of HOLDs & PTFs for the specified HOLD REASON
  ansible.builtin.set_fact:
    holds_with_specified_reason: []
    filter_param_value: "holdreason='{{ hold_reason }}'"

# Save only the HOLDs for the specified REASON ID
- name: Getting the HOLDs for reason ID <{{ hold_reason }}>
  ansible.builtin.set_fact:
    holds_with_specified_reason: "{{ holds_with_specified_reason + software_update_holds | selectattr('holdReason','equalto',hold_reason) | list }}"

# Add the singular PTF to the filter.
- name: Add the PTF to the CSI Query filter
  ansible.builtin.set_fact:
    filter_param_value: "{{ filter_param_value }} & (ename='{{ holds_with_specified_reason[0]['name'] }}')"
  when: holds_with_specified_reason is defined and holds_with_specified_reason | length == 1

# Add the first PTF to the filter.
- name: Add the 1st PTF to the CSI Query filter
  ansible.builtin.set_fact:
    filter_param_value: "{{ filter_param_value }} & ("
  when: holds_with_specified_reason is defined and holds_with_specified_reason | length > 1

# Add each PTF to the filter.
- name: Add the rest of the PTFs to the CSI Query filter
  ansible.builtin.set_fact:
    filter_param_value: "{{ filter_param_value }}ename='{{ holds_with_specified_reason[index]['name'] }}' | "
  loop: "{{ holds_with_specified_reason }}"
  loop_control:
    index_var: index
  when: holds_with_specified_reason is defined and holds_with_specified_reason | length > 1

# Add the ending parenthesis to end the list of PTFs in the filter parameter.
- name: Finalize the CSI Query filter parameter
  ansible.builtin.set_fact:
    filter_param_value: "{{ filter_param_value[:-3] + ')' }}"
  when: filter_param_value | length > 3 and holds_with_specified_reason is defined and holds_with_specified_reason | length > 1

# Set the lists of zones and entires to pass as request content to the CSI Query role.
- name: Initializing CSI Query request content parameters
  ansible.builtin.set_fact:
    zones: '["GLOBAL"]'
    entries: '["HOLDDATA"]'
    subentries: '["HOLDDATA"]'
    filter: "{{ filter_param_value }}"

############################
# Call the CSI Query role. #
############################
- name: Query a CSI data set for HOLD REASON ID <{{ hold_reason }}>
  ansible.builtin.include_role:
    name: zmf_swmgmt_csi_query

# Initialize lists to contain the HOLDATA text.
- name: Initialize lists
  ansible.builtin.set_fact:
    entries: "{{ csi_query_response.json['entries'] }}"
    subentries: []
    holddata_text_list: []
  when: csi_query_uuid_response is defined

# Consolidate a list of subentries.
- name: Getting the subentries out of the CSI query response
  ansible.builtin.set_fact:
    subentries: "{{ subentries + csi_query_response.json['entries'][index]['subentries'] }}"
  loop: "{{ csi_query_response.json['entries'] }}"
  loop_control:
    index_var: index
  when: csi_query_response.json['entries'] is defined and csi_query_response.json['entries'] | length > 0

# Create a list for the HOLDDATA text where each index contains one line of the text.
- name: Loop through the subentries to get the HOLDDATA text
  ansible.builtin.set_fact:
    holddata_text_list: "{{ holddata_text_list + subentries[index]['HOLDDATA'] }}"
  loop: "{{ subentries }}"
  loop_control:
    index_var: index
  when: subentries is defined and subentries | length > 0

# Create the filename to write the HOLDDATA text to.
- name: Create the name of the file to contain the HOLDDATA text
  ansible.builtin.set_fact:
    holds_for_reason_file: "{{ holds_for_reason_file }}{{ hold_reason }}.txt"

# Add a newline character to the end of the last line of HOLDDATA text.
# Without this newline character, the last line of text isn't written
# to the file.
- name: Formatting the HOLDDATA text
  ansible.builtin.set_fact:
    last_line: "{{ holddata_text_list[-1] + '\n' }}"
    formatted_list: "{{ holddata_text_list[:-1] }}"

# Put back the last line of HOLDDATA text.
- name: Formatting the HOLDDATA text
  ansible.builtin.set_fact:
    formatted_list: "{{ formatted_list + [last_line] }}"

# Delete the file where the HOLDDATA text will be written if it already exists.
- name: Delete the file if it already exists
  ansible.builtin.file:
    path: '{{ holds_for_reason_file }}'
    state: absent
  delegate_to: localhost

# Write HOLDATA text one line at a time.
- name: "Writing the HOLDDATA text to {{ holds_for_reason_file }}"
  ansible.builtin.lineinfile:
    path: '{{ holds_for_reason_file }}'
    line: "{{ formatted_list[index] }}"
    state: present
    create: true
    mode: '0644'
  delegate_to: localhost
  loop: "{{ formatted_list }}"
  loop_control:
    index_var: index
